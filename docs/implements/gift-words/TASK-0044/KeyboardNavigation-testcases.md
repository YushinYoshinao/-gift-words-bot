# TASK-0044: キーボードナビゲーション実装 - TDDテストケース定義書

## 📋 基本情報

- **タスクID**: TASK-0044
- **機能名**: キーボードナビゲーション（useKeyboardShortcuts）
- **作成日**: 2025-11-23
- **テストフレームワーク**: Vitest + @testing-library/react
- **テスト対象ファイル**: `src/hooks/useKeyboardShortcuts.ts`
- **テストファイル**: `src/hooks/__tests__/useKeyboardShortcuts.test.tsx`

---

## 🔧 開発言語・フレームワーク

### プログラミング言語

🔵 **青信号**: プロジェクト技術スタックに基づく

- **言語**: TypeScript 5.0+
- **言語選択の理由**:
  - プロジェクト標準言語
  - 型安全性によりテストケースの信頼性向上
  - KeyboardShortcutインターフェースの型検証が可能
- **テストに適した機能**:
  - インターフェース定義による明確なコントラクト
  - コンパイル時の型エラー検出
  - IDEによる自動補完サポート

### テストフレームワーク

🔵 **青信号**: プロジェクト標準テスト環境

- **テストフレームワーク**: Vitest 1.2+
- **テストライブラリ**: @testing-library/react 14.1+
- **フレームワーク選択の理由**:
  - Viteネイティブ統合で高速なテスト実行
  - React Hooksテスト用のrenderHookサポート
  - モック機能（vi.fn, vi.spyOn）の充実
  - 既存プロジェクトとの一貫性
- **テスト実行環境**:
  - Node.js 18+ LTS
  - jsdom（ブラウザAPI環境のシミュレーション）
  - TypeScript型チェック付き

---

## 📝 テストケース一覧

### 1. 正常系テストケース（基本的な動作）

#### テスト1-1: 単一ショートカットの登録と実行

🔵 **青信号**: 要件定義書・タスク仕様に基づく

- **テスト名**: 単一のキーボードショートカットが正しく登録され、キー押下時にコールバックが実行される
  - **何をテストするか**: useKeyboardShortcutsフックに登録したショートカットが、対応するキーイベント発生時に正しくコールバックを実行するか
  - **期待される動作**: 指定したキー（例: 'Escape'）が押されたときにコールバック関数が呼び出される

- **入力値**:
  ```typescript
  shortcuts = [
    {
      key: 'Escape',
      callback: mockCallback,
      description: 'トップページに戻る'
    }
  ]
  ```
  - **入力データの意味**: 最もシンプルなショートカット登録（修飾キーなし）
  - **選択理由**: 基本動作の確認として最小構成をテスト

- **期待される結果**:
  - Escapeキー押下時に`mockCallback`が1回呼ばれる
  - `event.preventDefault()`が実行される
  - **期待結果の理由**: ブラウザのデフォルト動作（ダイアログ閉じるなど）を抑制し、カスタム動作を実行するため

- **テストの目的**: 最も基本的なキーボードショートカット機能が正しく動作するか確認
  - **確認ポイント**:
    - イベントリスナーが正しく登録されているか
    - キーイベントが正しくハンドリングされるか
    - コールバックが確実に実行されるか

#### テスト1-2: 修飾キー付きショートカットの実行（Ctrl+S）

🔵 **青信号**: TASK-0044仕様書の使用例に基づく

- **テスト名**: Ctrl+Sで指定したコールバックが実行される
  - **何をテストするか**: 修飾キー（Ctrl）との組み合わせショートカットが正しく動作するか
  - **期待される動作**: Ctrlキーを押しながら's'キーを押したときのみコールバックが実行される

- **入力値**:
  ```typescript
  shortcuts = [
    {
      key: 's',
      ctrlKey: true,
      callback: mockCallback,
      description: '画像として保存'
    }
  ]
  ```
  - **入力データの意味**: 実際の使用シナリオ（DisplayPageでの画像保存）を再現
  - **選択理由**: 最も重要な機能要件（NFR-205）の中核となるショートカット

- **期待される結果**:
  - Ctrl+S押下時に`mockCallback`が1回呼ばれる
  - 's'キーのみ押下時には`mockCallback`が呼ばれない
  - **期待結果の理由**: 修飾キーの有無で動作を正しく区別できることを保証

- **テストの目的**: 修飾キーを含むショートカットが正しく機能するか確認
  - **確認ポイント**:
    - event.ctrlKeyの判定が正しいか
    - 修飾キーなしのキー押下と正しく区別できるか

#### テスト1-3: 複数ショートカットの同時登録と動作

🔵 **青信号**: 要件定義書のエッジケースEDGE-002に基づく

- **テスト名**: 複数のショートカットが同時に機能する
  - **何をテストするか**: 複数のショートカットを同時に登録した場合、それぞれが独立して正しく動作するか
  - **期待される動作**: 登録した各ショートカットが互いに干渉せず、それぞれ正しく実行される

- **入力値**:
  ```typescript
  shortcuts = [
    { key: 's', ctrlKey: true, callback: mockSaveCallback, description: '保存' },
    { key: 'Escape', callback: mockEscapeCallback, description: '戻る' }
  ]
  ```
  - **入力データの意味**: DisplayPageでの実際の使用シナリオ（複数機能の併用）
  - **選択理由**: 実運用で最も一般的なパターン

- **期待される結果**:
  - Ctrl+S押下時: `mockSaveCallback`のみ呼ばれる
  - Escape押下時: `mockEscapeCallback`のみ呼ばれる
  - 両方のコールバックが正しく分離されて実行される
  - **期待結果の理由**: ショートカット間の独立性とフック内部のルーティング正確性を保証

- **テストの目的**: 複数ショートカットの共存と正しい振り分けを確認
  - **確認ポイント**:
    - shortcuts配列の走査ロジックが正しいか
    - 条件分岐が正確に機能するか

#### テスト1-4: ShiftキーやAltキーとの組み合わせ

🟡 **黄信号**: 一般的なキーボードショートカットパターンから推測

- **テスト名**: Shift+Enterでコールバックが実行される
  - **何をテストするか**: Ctrl以外の修飾キー（Shift, Alt）も正しく機能するか
  - **期待される動作**: shiftKey, altKeyの判定が正確に行われる

- **入力値**:
  ```typescript
  shortcuts = [
    { key: 'Enter', shiftKey: true, callback: mockCallback, description: 'Shift+Enter' }
  ]
  ```
  - **入力データの意味**: Shift修飾キーの動作確認
  - **選択理由**: すべての修飾キータイプの網羅性確保

- **期待される結果**:
  - Shift+Enter押下時に`mockCallback`が呼ばれる
  - Enterキーのみでは呼ばれない
  - **期待結果の理由**: 全修飾キータイプの正確な判定を保証

- **テストの目的**: すべての修飾キーオプションの動作確認
  - **確認ポイント**:
    - shiftKey, altKeyのフラグ判定が正確か

---

### 2. 異常系テストケース（エラーハンドリング）

#### テスト2-1: 空のshortcuts配列でもエラーが発生しない

🔵 **青信号**: 要件定義書のエッジケースEDGE-001に基づく

- **テスト名**: 空のshortcuts配列でもエラーが発生しない
  - **エラーケースの概要**: ショートカットが1つも登録されていない状態
  - **エラー処理の重要性**: 初期化時やショートカット未設定時にクラッシュを防ぐ

- **入力値**:
  ```typescript
  shortcuts = []
  ```
  - **不正な理由**: 通常の使用では少なくとも1つのショートカットが登録されるが、技術的に空配列も許容すべき
  - **実際の発生シナリオ**: 動的にショートカットを追加する場合の初期状態、条件によってショートカットを無効化する場合

- **期待される結果**:
  - エラーがスローされない
  - イベントリスナーは登録されるが、キー押下時に何も実行されない
  - **エラーメッセージの内容**: なし（エラーにならない）
  - **システムの安全性**: フックがクラッシュせず、安全に動作し続ける

- **テストの目的**: 空配列での堅牢性を確認
  - **品質保証の観点**: 防御的プログラミングによる信頼性向上

#### テスト2-2: コールバック実行中に例外が発生してもシステムが継続動作する

🟡 **黄信号**: 一般的なエラーハンドリングベストプラクティス

- **テスト名**: コールバック内で例外がスローされてもフックが継続動作する
  - **エラーケースの概要**: ユーザー定義のコールバック関数内でエラーが発生
  - **エラー処理の重要性**: コールバックのバグがフック全体を停止させないことを保証

- **入力値**:
  ```typescript
  shortcuts = [
    {
      key: 'a',
      callback: () => { throw new Error('Test error'); },
      description: 'Error test'
    },
    {
      key: 'b',
      callback: mockCallback,
      description: 'Normal callback'
    }
  ]
  ```
  - **不正な理由**: コールバックが例外をスロー（実装バグやAPI呼び出し失敗など）
  - **実際の発生シナリオ**: ネットワークエラー、DOM要素の不在、非同期処理の失敗

- **期待される結果**:
  - 'a'キー押下時に例外がスローされる
  - その後、'b'キー押下時に`mockCallback`が正常に実行される
  - **システムの安全性**: 1つのコールバックエラーが他のショートカットに影響しない

- **テストの目的**: エラー分離とフックの継続動作を確認
  - **品質保証の観点**: 部分的な障害がシステム全体に波及しないことを保証

---

### 3. 境界値テストケース（最小値、最大値、null等）

#### テスト3-1: 同じキーの重複登録で両方のコールバックが実行される

🔵 **青信号**: 要件定義書のエッジケースEDGE-002に基づく

- **テスト名**: 同じキーの重複登録で両方のコールバックが順次実行される
  - **境界値の意味**: ショートカット配列内に同一キーが複数存在する状態
  - **境界値での動作保証**: 重複登録時の動作が明確であることを確認

- **入力値**:
  ```typescript
  shortcuts = [
    { key: 's', ctrlKey: true, callback: mockCallback1, description: 'Save 1' },
    { key: 's', ctrlKey: true, callback: mockCallback2, description: 'Save 2' }
  ]
  ```
  - **境界値選択の根拠**: 配列走査の完全性を検証（早期returnがないことを確認）
  - **実際の使用場面**: プラグインシステムや複数コンポーネントからのショートカット登録

- **期待される結果**:
  - Ctrl+S押下時に`mockCallback1`と`mockCallback2`の両方が順次呼ばれる
  - 呼び出し順序は配列の順序と一致する
  - **境界での正確性**: すべての登録済みコールバックが確実に実行される
  - **一貫した動作**: 1つ目のコールバック実行後も2つ目が確実に実行される

- **テストの目的**: ショートカット走査ロジックの完全性を確認
  - **堅牢性の確認**: forEachループが途中で中断されないことを保証

#### テスト3-2: 非常に長いショートカット配列でもパフォーマンスが保たれる

🟡 **黄信号**: パフォーマンス要件NFR-002から推測

- **テスト名**: 100個のショートカット登録でもイベント処理が高速
  - **境界値の意味**: 大量のショートカット登録による処理負荷
  - **境界値での動作保証**: O(n)の線形探索でも十分高速であることを確認

- **入力値**:
  ```typescript
  shortcuts = Array.from({ length: 100 }, (_, i) => ({
    key: `key${i}`,
    callback: vi.fn(),
    description: `Shortcut ${i}`
  }))
  ```
  - **境界値選択の根拠**: 実運用で想定される最大ショートカット数の10倍
  - **実際の使用場面**: 大規模アプリケーションや複数プラグインの併用

- **期待される結果**:
  - イベント処理時間が16.67ms以下（60fps維持）
  - すべてのショートカットが正しく機能する
  - **境界での正確性**: 大量登録でもロジックが正確に動作
  - **一貫した動作**: パフォーマンス劣化が許容範囲内

- **テストの目的**: スケーラビリティとパフォーマンス要件の確認
  - **堅牢性の確認**: 極端な条件下でもNFR-002（60fps）を満たす

#### テスト3-3: 特殊キー（F1-F12, Tab, Spaceなど）の動作確認

🟡 **黄信号**: 一般的なキーボードショートカットパターン

- **テスト名**: F1キーやTabキーなどの特殊キーが正しく動作する
  - **境界値の意味**: 通常のアルファベット以外の特殊キー
  - **境界値での動作保証**: event.keyのすべての値タイプに対応

- **入力値**:
  ```typescript
  shortcuts = [
    { key: 'F1', callback: mockF1Callback, description: 'Help' },
    { key: 'Tab', callback: mockTabCallback, description: 'Tab' },
    { key: ' ', callback: mockSpaceCallback, description: 'Space' }
  ]
  ```
  - **境界値選択の根拠**: KeyboardEvent.keyの特殊値をカバー
  - **実際の使用場面**: ヘルプ表示（F1）、フォーカス移動（Tab）、再生/停止（Space）

- **期待される結果**:
  - 各特殊キー押下時に対応するコールバックが呼ばれる
  - **境界での正確性**: 文字列比較が特殊キーでも正しく機能
  - **一貫した動作**: すべてのKeyboardEvent.key値に対応

- **テストの目的**: キー種別の網羅性を確認
  - **堅牢性の確認**: あらゆるキータイプに対応できることを保証

---

### 4. ライフサイクルテストケース

#### テスト4-1: コンポーネントマウント時にイベントリスナーが登録される

🔵 **青信号**: React Hooksの標準パターン

- **テスト名**: useKeyboardShortcuts呼び出し時にwindow.addEventListenerが実行される
  - **何をテストするか**: useEffectによるイベントリスナー登録が正しく行われるか
  - **期待される動作**: フックのマウント時にkeydownイベントリスナーが追加される

- **入力値**:
  ```typescript
  shortcuts = [{ key: 'a', callback: vi.fn(), description: 'Test' }]
  ```
  - **入力データの意味**: 最小構成のショートカット
  - **選択理由**: ライフサイクルテストはショートカット内容に依存しない

- **期待される結果**:
  - `window.addEventListener('keydown', ...)` が呼ばれる
  - イベントハンドラー関数が登録される
  - **期待結果の理由**: useEffectの副作用が正しく実行されることを保証

- **テストの目的**: フックの初期化処理を確認
  - **確認ポイント**:
    - useEffectが正しくトリガーされるか
    - addEventListenerの引数が正しいか

#### テスト4-2: コンポーネントアンマウント時にイベントリスナーが削除される

🔵 **青信号**: 要件定義書のエッジケースEDGE-003に基づく

- **テスト名**: アンマウント時にwindow.removeEventListenerが実行される
  - **何をテストするか**: useEffectのクリーンアップ関数が正しく動作するか
  - **期待される動作**: コンポーネントアンマウント時にイベントリスナーが確実に削除される

- **入力値**:
  ```typescript
  shortcuts = [{ key: 'a', callback: vi.fn(), description: 'Test' }]
  ```
  - **入力データの意味**: 最小構成のショートカット
  - **選択理由**: クリーンアップテストはショートカット内容に依存しない

- **期待される結果**:
  - アンマウント後、`window.removeEventListener('keydown', ...)` が呼ばれる
  - イベントハンドラーが完全に削除される
  - アンマウント後のキー押下でコールバックが呼ばれない
  - **期待結果の理由**: メモリリークを防ぎ、システムの安定性を保証

- **テストの目的**: メモリリーク防止とクリーンアップ処理の確認
  - **確認ポイント**:
    - useEffectのreturn関数が実行されるか
    - イベントリスナーが確実に削除されるか
    - アンマウント後にイベントが発火しないか

#### テスト4-3: shortcuts配列の動的変更時にイベントリスナーが再登録される

🔵 **青信号**: 要件定義書のエッジケースEDGE-004に基づく

- **テスト名**: shortcuts配列が変更されたときにイベントリスナーが更新される
  - **何をテストするか**: useEffectの依存配列（handleKeyDown）が正しく機能するか
  - **期待される動作**: shortcuts変更時に古いリスナーが削除され、新しいリスナーが登録される

- **入力値**:
  ```typescript
  // 初期状態
  shortcuts1 = [{ key: 'a', callback: mockCallback1, description: 'Test 1' }]

  // 更新後
  shortcuts2 = [{ key: 'b', callback: mockCallback2, description: 'Test 2' }]
  ```
  - **入力データの意味**: ショートカット構成の動的変更
  - **選択理由**: 実運用での動的なショートカット管理を想定

- **期待される結果**:
  - shortcuts更新前: 'a'キーで`mockCallback1`が呼ばれる
  - shortcuts更新後: 'a'キーで何も呼ばれない、'b'キーで`mockCallback2`が呼ばれる
  - **期待結果の理由**: useEffectの依存配列による再実行が正しく機能することを保証

- **テストの目的**: 動的なショートカット変更への対応を確認
  - **確認ポイント**:
    - useCallbackのメモ化が正しく機能するか
    - useEffectの依存配列が適切に設定されているか
    - 古いイベントリスナーが確実に削除されるか

---

### 5. 統合テストケース

#### テスト5-1: DisplayPageでのCtrl+S実行シナリオ

🔵 **青信号**: TASK-0044仕様書の使用例に基づく

- **テスト名**: DisplayPageでCtrl+Sを押すと画像保存処理が実行される（統合テスト）
  - **何をテストするか**: 実際のコンポーネントでのuseKeyboardShortcuts使用シナリオ
  - **期待される動作**: Ctrl+S押下時にuseImageExportのexportAsImageが呼ばれる

- **入力値**:
  ```typescript
  // DisplayPageコンポーネント内
  useKeyboardShortcuts([
    { key: 's', ctrlKey: true, callback: () => exportAsImage(element), description: '保存' }
  ])
  ```
  - **入力データの意味**: 実際の製品コードでの使用パターン
  - **選択理由**: エンドツーエンドでの動作確認

- **期待される結果**:
  - Ctrl+S押下時に`exportAsImage`が呼ばれる
  - DOM要素が正しく渡される
  - **期待結果の理由**: フックとコンポーネントの統合が正しく機能することを保証

- **テストの目的**: 実際の使用シナリオでの動作確認
  - **確認ポイント**:
    - コンポーネントとフックの結合
    - 実際のDOM操作との連携

#### テスト5-2: DisplayPageでのEscape実行シナリオ

🔵 **青信号**: TASK-0044仕様書の使用例に基づく

- **テスト名**: DisplayPageでEscapeを押すとトップページに遷移する（統合テスト）
  - **何をテストするか**: Escapeキーによるナビゲーション動作
  - **期待される動作**: Escape押下時にuseNavigate('/')が呼ばれる

- **入力値**:
  ```typescript
  useKeyboardShortcuts([
    { key: 'Escape', callback: () => navigate('/'), description: 'トップへ戻る' }
  ])
  ```
  - **入力データの意味**: 実際の製品コードでの使用パターン
  - **選択理由**: ルーティングとの統合確認

- **期待される結果**:
  - Escape押下時に`navigate('/')`が呼ばれる
  - **期待結果の理由**: React Routerとの統合が正しく機能することを保証

- **テストの目的**: ナビゲーション機能との統合確認
  - **確認ポイント**:
    - React Router v6のuseNavigateとの連携
    - ページ遷移トリガーの正確性

---

## 📊 テストケース実装時の日本語コメント指針

### テストケース開始時のコメント

```typescript
it('単一のキーボードショートカットが正しく登録され、キー押下時にコールバックが実行される', () => {
  // 【テスト目的】: useKeyboardShortcutsフックの基本動作を確認 🔵
  // 【テスト内容】: Escapeキー押下時にコールバックが実行されることを検証 🔵
  // 【期待される動作】: Escapeキー押下でmockCallbackが1回呼ばれ、event.preventDefault()が実行される 🔵
  // 🔵 信頼性レベル: NFR-205要件定義書に基づく確実なテスト
```

### Given（準備フェーズ）のコメント

```typescript
  // 【テストデータ準備】: 単一ショートカットを準備し、基本動作を確認 🔵
  const mockCallback = vi.fn();
  const shortcuts = [
    { key: 'Escape', callback: mockCallback, description: 'トップページに戻る' }
  ];

  // 【初期条件設定】: useKeyboardShortcutsフックをレンダリング 🔵
  renderHook(() => useKeyboardShortcuts(shortcuts));

  // 【前提条件確認】: イベントリスナーが登録されていることを確認 🔵
  expect(window.addEventListener).toHaveBeenCalledWith('keydown', expect.any(Function));
```

### When（実行フェーズ）のコメント

```typescript
  // 【実際の処理実行】: Escapeキー押下イベントを発火 🔵
  const event = new KeyboardEvent('keydown', { key: 'Escape' });

  // 【処理内容】: window.dispatchEventでkeydownイベントをシミュレート 🔵
  act(() => {
    window.dispatchEvent(event);
  });

  // 【実行タイミング】: イベントリスナー登録直後にキーイベントを発生 🔵
```

### Then（検証フェーズ）のコメント

```typescript
  // 【結果検証】: コールバックが正しく実行されたことを確認 🔵
  // 【期待値確認】: mockCallbackが正確に1回呼ばれることを検証 🔵
  expect(mockCallback).toHaveBeenCalledTimes(1);

  // 【品質保証】: event.preventDefault()の実行により、ブラウザデフォルト動作が抑制されることを保証 🔵
```

### セットアップ・クリーンアップのコメント

```typescript
beforeEach(() => {
  // 【テスト前準備】: window.addEventListenerをスパイ化し、イベントリスナー登録を監視 🔵
  vi.spyOn(window, 'addEventListener');
  vi.spyOn(window, 'removeEventListener');

  // 【環境初期化】: モックをクリアし、テスト間の独立性を保証 🔵
  vi.clearAllMocks();
});

afterEach(() => {
  // 【テスト後処理】: すべてのモックをリストアし、次のテストに影響しないようにする 🔵
  vi.restoreAllMocks();

  // 【状態復元】: グローバルイベントリスナーを元の状態に戻す 🔵
});
```

---

## 📈 テストカバレッジ目標

### カバレッジ目標

🔵 **青信号**: プロジェクト品質基準に基づく

- **ステートメントカバレッジ**: 100%
- **ブランチカバレッジ**: 100%（if文、修飾キー判定のすべての分岐）
- **関数カバレッジ**: 100%（handleKeyDown, useEffect cleanup）
- **ラインカバレッジ**: 100%

### 要件網羅率

- **NFR-205**: キーボード操作可能 → テスト1-1, 1-2, 1-3, 5-1, 5-2でカバー（100%）
- **NFR-002**: 60fps維持 → テスト3-2でパフォーマンス確認（100%）
- **エッジケース**: EDGE-001〜004すべてカバー（100%）

---

## 🎯 品質判定

### 品質判定結果: ✅ 高品質

**評価基準**:

✅ **テストケース分類**: 正常系・異常系・境界値・ライフサイクル・統合テストがすべて網羅されている
  - 正常系: 4テストケース
  - 異常系: 2テストケース
  - 境界値: 3テストケース
  - ライフサイクル: 3テストケース
  - 統合テスト: 2テストケース
  - **合計**: 14テストケース

✅ **期待値定義**: 各テストケースの期待値が具体的かつ明確
  - すべてのテストで入力値と期待される結果が明記されている
  - Given-When-Then形式で構造化されている
  - 日本語コメント指針が詳細に定義されている

✅ **技術選択**: プログラミング言語・テストフレームワークが確定
  - TypeScript 5.0+（プロジェクト標準）
  - Vitest 1.2+ + @testing-library/react 14.1+（既存環境と一貫性）
  - jsdom環境でブラウザAPIをシミュレーション

✅ **実装可能性**: 現在の技術スタックで実現可能
  - 既存テストパターン（useTypewriter, useImageExport）と同様の構造
  - renderHook, act, vi.fnなど確立されたテストAPIを使用
  - 技術的難易度: 中（KeyboardEventのシミュレーションが必要）

---

## 📝 次のステップ

### 推奨コマンド

次のお勧めステップ: `/tsumiki:tdd-red` でRedフェーズ（失敗テスト作成）を開始します。

### Redフェーズの準備

以下のテストファイルを作成します：
- `src/hooks/__tests__/useKeyboardShortcuts.test.tsx`

実装予定のテスト構成：
```typescript
describe('useKeyboardShortcuts - TASK-0044', () => {
  describe('正常系テスト', () => {
    it('単一のキーボードショートカットが正しく登録され、キー押下時にコールバックが実行される', ...)
    it('Ctrl+Sで指定したコールバックが実行される', ...)
    it('複数のショートカットが同時に機能する', ...)
    it('Shift+Enterでコールバックが実行される', ...)
  })

  describe('異常系テスト', () => {
    it('空のshortcuts配列でもエラーが発生しない', ...)
    it('コールバック内で例外がスローされてもフックが継続動作する', ...)
  })

  describe('境界値テスト', () => {
    it('同じキーの重複登録で両方のコールバックが順次実行される', ...)
    it('100個のショートカット登録でもイベント処理が高速', ...)
    it('F1キーやTabキーなどの特殊キーが正しく動作する', ...)
  })

  describe('ライフサイクルテスト', () => {
    it('useKeyboardShortcuts呼び出し時にwindow.addEventListenerが実行される', ...)
    it('アンマウント時にwindow.removeEventListenerが実行される', ...)
    it('shortcuts配列が変更されたときにイベントリスナーが更新される', ...)
  })

  describe('統合テスト', () => {
    it('DisplayPageでCtrl+Sを押すと画像保存処理が実行される', ...)
    it('DisplayPageでEscapeを押すとトップページに遷移する', ...)
  })
})
```

---

**作成日**: 2025-11-23
**作成者**: Claude Code (TDD Testcases Phase)
**信頼性**: 🔵 高信頼（NFR-205要件＋既存テストパターンに基づく）
**テストケース数**: 14ケース
**ドキュメントバージョン**: 1.0

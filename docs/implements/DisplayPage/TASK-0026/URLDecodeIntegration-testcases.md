# TASK-0026: URLデコード機能のDisplayPage統合 - テストケース定義書

## 生成情報
- **生成日**: 2025-11-22
- **生成ツール**: /tsumiki:tdd-testcases
- **タスクID**: TASK-0026
- **タスク名**: URLデコード機能のDisplayPage統合
- **要件定義書**: URLDecodeIntegration-requirements.md
- **依存タスク**: TASK-0018(URLデコーダー完了), TASK-0025(DisplayPage基本構造完了)

---

## 開発言語・フレームワーク

### プログラミング言語

- **言語**: TypeScript 5.0+
- **言語選択の理由**: 型安全性によりデコード処理のエラーを早期発見、REQ-103のBase64デコード仕様を型定義で明確化できる
- **テストに適した機能**: インターフェース定義により期待値の型が明確、テストコードの保守性向上
- 🔵 信頼性レベル: tech-stack.md Line 23に基づく

### テストフレームワーク

- **テストフレームワーク**: Vitest 1.2.0+
- **フレームワーク選択の理由**: Viteネイティブ統合で高速、React Testing Libraryとの親和性が高い、既存プロジェクトで使用中
- **テスト実行環境**: jsdom環境（ブラウザAPI模擬）
- **アサーションライブラリ**: Vitest (expect)
- **ユーザーイベントシミュレーション**: @testing-library/user-event
- 🔵 信頼性レベル: vitest.config.ts Line 14-16, 既存テストファイルのパターンに基づく

---

## テストケース一覧

### 1. 正常系テストケース（基本的な動作）

#### TC-DECODE-001: 正常なBase64データをデコードして表示する

- **テスト名**: 正常なBase64データをデコードして表示する
  - **何をテストするか**: URLパラメータから正しくデータをデコードし、DisplayPageに表示する機能
  - **期待される動作**: Base64エンコードされた有効なGiftWordDataをデコードし、エラーなく表示される

- **入力値**:
  ```typescript
  // URL: /display?data=eyJ3b3JkIjoi5oSf6KySIiwibWVhbmluZyI6IuOBhOOBpOCCguOBguOCiuOBjOOBqOOBhiJ9
  // デコード後: { word: "感謝", meaning: "いつもありがとう" }
  ```
  - **入力データの意味**: 日本語を含む一般的な贈る言葉データ。最も頻繁に使用されるパターンを代表
  - **選択理由**: REQ-102とREQ-103の正常系動作を検証

- **期待される結果**:
  - `decodeGiftWordData()`が成功（`success: true`）
  - `data.word`が「感謝」
  - `data.meaning`が「いつもありがとう」
  - ErrorPageが表示されない
  - トーストメッセージが表示されない
  - **期待結果の理由**: 正常なデータは適切にデコードされ、ユーザーに表示されるべき

- **テストの目的**: REQ-103（Base64デコード）の正常動作を確認
  - **確認ポイント**:
    - Base64デコードが正しく実行される
    - JSONパースが成功する
    - データがStateに正しく設定される
    - エラーStateが設定されない

- 🔵 信頼性レベル: REQ-102, REQ-103, urlEncoder.test.ts Line 128-141のパターンに基づく

---

#### TC-DECODE-002: 日本語（ひらがな、カタカナ、漢字）を正しくデコードする

- **テスト名**: 日本語（ひらがな、カタカナ、漢字）を正しくデコードする
  - **何をテストするか**: 多様な日本語文字種を含むデータのデコード精度
  - **期待される動作**: すべての日本語文字種が文字化けせず正しくデコードされる

- **入力値**:
  ```typescript
  // デコード後: {
  //   word: "ありがとうカタカナ漢字混在",
  //   meaning: "ひらがな、カタカナ、漢字が混ざった意味の説明文です。"
  // }
  ```
  - **入力データの意味**: 日本語の3つの文字体系（ひらがな、カタカナ、漢字）すべてを含む
  - **選択理由**: REQ-021（日本語対応）の包括的な検証

- **期待される結果**:
  - デコード成功
  - すべての文字種が正しく保持される
  - 文字化けが発生しない
  - **期待結果の理由**: URIエンコード→Base64エンコード→デコードのラウンドトリップで文字が保持されるべき

- **テストの目的**: REQ-021（日本語対応）とREQ-103（デコード）の統合動作確認
  - **確認ポイント**:
    - `encodeURIComponent`→`atob`のデコードパイプラインが機能
    - UTF-8文字列が正しく処理される

- 🔵 信頼性レベル: REQ-021, urlEncoder.test.ts Line 143-156, DisplayPage.test.tsx Line 217-239に基づく

---

#### TC-DECODE-003: 特殊文字（改行、引用符、記号）を正しくデコードする

- **テスト名**: 特殊文字（改行、引用符、記号）を正しくデコードする
  - **何をテストするか**: JSON特殊文字やHTML特殊文字のエスケープ処理
  - **期待される動作**: すべての特殊文字が安全にデコードされ、XSS攻撃のリスクがない

- **入力値**:
  ```typescript
  // デコード後: {
  //   word: 'Test & "Special" <Characters>',
  //   meaning: "It's working!\n100% 🎉\nLine 2"
  // }
  ```
  - **入力データの意味**: JSON/HTML特殊文字、改行、絵文字を含む
  - **選択理由**: セキュリティ要件（XSS対策）とデータ完全性の検証

- **期待される結果**:
  - デコード成功
  - `&`, `"`, `<`, `>`, `'`, `\n`が正しく保持される
  - XSSインジェクションが発生しない（React自動エスケープ）
  - **期待結果の理由**: 特殊文字を含むテキストも正しく表示されるべき（セキュリティ制約内で）

- **テストの目的**: セキュリティ要件（XSS対策）とREQ-103の堅牢性確認
  - **確認ポイント**:
    - JSON.parse()が特殊文字を正しく処理
    - Reactのデフォルトエスケープが機能
    - `dangerouslySetInnerHTML`が使用されていない

- 🔵 信頼性レベル: セキュリティ制約条件、urlEncoder.test.ts Line 52-62に基づく

---

### 2. 異常系テストケース（エラーハンドリング）

#### TC-DECODE-004: URLパラメータが空文字列の場合はエラーを表示

- **テスト名**: URLパラメータが空文字列の場合はエラーを表示
  - **エラーケースの概要**: URLに`?data=`とパラメータ名だけがあり値が空
  - **エラー処理の重要性**: ユーザーがURLを手動編集した際のクラッシュ防止

- **入力値**:
  ```typescript
  // URL: /display?data=
  // searchParams.get('data') → ""
  ```
  - **不正な理由**: Base64文字列として無効（空文字列はデコード不可）
  - **実際の発生シナリオ**: ユーザーがURLを手動でコピー&ペーストした際に値部分が欠落

- **期待される結果**:
  - `decodeGiftWordData("")` → `{ success: false, error: ERROR_MESSAGES.INVALID_URL }`
  - `setError(ERROR_MESSAGES.INVALID_URL)`が呼ばれる
  - `showToast(ERROR_MESSAGES.INVALID_URL, 'error')`が呼ばれる
  - ErrorPageが表示される
  - **エラーメッセージの内容**: 「URLが正しくありません」（ERROR_MESSAGES.INVALID_URL）
  - **システムの安全性**: アプリケーションがクラッシュせず、エラー画面に遷移

- **テストの目的**: REQ-213（エラーメッセージ表示）の動作確認
  - **品質保証の観点**: ユーザー入力エラーに対する適切なフィードバック提供

- 🟡 信頼性レベル: REQ-213から推測、urlEncoder.test.ts Line 186-192のパターンに基づく

---

#### TC-DECODE-005: 不正なBase64データの場合はエラーを表示

- **テスト名**: 不正なBase64データの場合はエラーを表示
  - **エラーケースの概要**: Base64として無効な文字列（デコード不可能）
  - **エラー処理の重要性**: 破損したURLや改ざんされたURLからの保護

- **入力値**:
  ```typescript
  // URL: /display?data=invalid!!!base64
  // Base64として無効な文字列
  ```
  - **不正な理由**: `!`はBase64文字セットに含まれない
  - **実際の発生シナリオ**: URLが破損、またはユーザーがURLを手動で改変

- **期待される結果**:
  - `atob()`がエラーをスロー
  - try-catchでエラーを捕捉
  - `{ success: false, error: ERROR_MESSAGES.DECODE_FAILED }`
  - `showToast(ERROR_MESSAGES.DECODE_FAILED, 'error')`が呼ばれる
  - ErrorPageが表示される
  - **エラーメッセージの内容**: 「データの読み込みに失敗しました」（ERROR_MESSAGES.DECODE_FAILED）
  - **システムの安全性**: アプリケーションが例外をキャッチしてグレースフルに処理

- **テストの目的**: REQ-103（デコード失敗）とREQ-213（エラー表示）の統合確認
  - **品質保証の観点**: 予期しない入力に対する堅牢性

- 🔵 信頼性レベル: REQ-103, REQ-213, urlEncoder.test.ts Line 202-208に基づく

---

#### TC-DECODE-006: JSONパース失敗の場合はエラーを表示

- **テスト名**: JSONパース失敗の場合はエラーを表示
  - **エラーケースの概要**: Base64デコードは成功するが、結果がJSONとして無効
  - **エラー処理の重要性**: データ破損や不正なデータ構造からの保護

- **入力値**:
  ```typescript
  // Base64エンコードされた "not valid json{"
  const invalidJson = btoa('not valid json{');
  // URL: /display?data=${invalidJson}
  ```
  - **不正な理由**: JSON.parse()が失敗する形式
  - **実際の発生シナリオ**: エンコード前のデータが破損、またはエンコード処理の不具合

- **期待される結果**:
  - `JSON.parse()`がSyntaxErrorをスロー
  - try-catchでエラーを捕捉
  - `{ success: false, error: ERROR_MESSAGES.DECODE_FAILED }`
  - ErrorPage表示 + トーストメッセージ
  - **エラーメッセージの内容**: 「データの読み込みに失敗しました」
  - **システムの安全性**: JSON解析エラーがユーザーに露出せず、安全に処理される

- **テストの目的**: REQ-103のエラーハンドリング（JSON解析段階）を確認
  - **品質保証の観点**: デコードパイプライン全体のエラーハンドリング網羅性

- 🔵 信頼性レベル: REQ-103, urlEncoder.test.ts Line 210-217に基づく

---

#### TC-DECODE-007: wordが欠けている場合はエラーを表示

- **テスト名**: wordが欠けている場合はエラーを表示
  - **エラーケースの概要**: デコード・JSONパースは成功するが、必須フィールドwordが空またはundefined
  - **エラー処理の重要性**: データ完全性の保証、不完全なデータの表示防止

- **入力値**:
  ```typescript
  // デコード後: { word: "", meaning: "意味のみ" }
  // または: { meaning: "意味のみ" } (wordフィールドなし)
  ```
  - **不正な理由**: GiftWordDataインターフェースの`word: string`が必須だが空
  - **実際の発生シナリオ**: エンコード側のバリデーション不備、データ破損

- **期待される結果**:
  - データバリデーション: `!data.word`が`true`
  - `{ success: false, error: ERROR_MESSAGES.INVALID_DATA }`
  - `showToast(ERROR_MESSAGES.INVALID_DATA, 'error')`が呼ばれる
  - ErrorPageが表示される
  - **エラーメッセージの内容**: 「データが不正です」（ERROR_MESSAGES.INVALID_DATA）
  - **システムの安全性**: 不完全なデータで表示ページがレンダリングされない

- **テストの目的**: データバリデーション（REQ-103関連）とREQ-213の確認
  - **品質保証の観点**: データ完全性チェックによる信頼性向上

- 🟡 信頼性レベル: データバリデーションロジックから推測、urlEncoder.test.ts Line 219-227に基づく

---

#### TC-DECODE-008: meaningが欠けている場合はエラーを表示

- **テスト名**: meaningが欠けている場合はエラーを表示
  - **エラーケースの概要**: デコード・JSONパースは成功するが、必須フィールドmeaningが空またはundefined
  - **エラー処理の重要性**: TC-DECODE-007と同様、データ完全性の保証

- **入力値**:
  ```typescript
  // デコード後: { word: "感謝", meaning: "" }
  // または: { word: "感謝" } (meaningフィールドなし)
  ```
  - **不正な理由**: GiftWordDataインターフェースの`meaning: string`が必須だが空
  - **実際の発生シナリオ**: ユーザーがフォームで意味を入力せずに送信（フロントエンドバリデーション回避）

- **期待される結果**:
  - データバリデーション: `!data.meaning`が`true`
  - `{ success: false, error: ERROR_MESSAGES.INVALID_DATA }`
  - ErrorPage表示 + トーストメッセージ
  - **エラーメッセージの内容**: 「データが不正です」
  - **システムの安全性**: 不完全なデータで表示ページがレンダリングされない

- **テストの目的**: データバリデーション（word/meaningの両方）の網羅性確認
  - **品質保証の観点**: すべての必須フィールドが検証される

- 🟡 信頼性レベル: データバリデーションロジックから推測、urlEncoder.test.ts Line 229-237に基づく

---

#### TC-DECODE-009: デコード失敗時にトーストメッセージが表示される

- **テスト名**: デコード失敗時にトーストメッセージが表示される
  - **エラーケースの概要**: デコード失敗時のユーザーフィードバック機能
  - **エラー処理の重要性**: エラー発生をユーザーに明確に通知し、UX向上

- **入力値**:
  ```typescript
  // 不正なBase64データ
  // URL: /display?data=invalid!!!base64
  ```
  - **不正な理由**: TC-DECODE-005と同様
  - **実際の発生シナリオ**: URLが破損したケース

- **期待される結果**:
  - `showToast(ERROR_MESSAGES.DECODE_FAILED, 'error')`が呼ばれる
  - ToastContext経由でトーストメッセージが表示される
  - トーストタイプが`'error'`
  - トーストメッセージが「データの読み込みに失敗しました」
  - ErrorPageとトーストメッセージの両方が表示される
  - **エラーメッセージの内容**: 視覚的なフィードバック（トースト）+ 詳細なエラーページ
  - **システムの安全性**: ユーザーが問題を認識でき、次のアクションを取れる

- **テストの目的**: REQ-213（エラーメッセージ表示）とToastContext統合の確認
  - **品質保証の観点**: エラー通知の多層化（トースト+エラーページ）

- 🟡 信頼性レベル: REQ-213, ToastContext.tsx Line 29-45に基づく

---

### 3. 境界値テストケース（最小値、最大値、null等）

#### TC-DECODE-010: 最大長データ（word: 50文字、meaning: 300文字）を正しくデコードする

- **テスト名**: 最大長データ（word: 50文字、meaning: 300文字）を正しくデコードする
  - **境界値の意味**: VALIDATION_RULES.MAX_WORD_LENGTH(50)とMAX_MEANING_LENGTH(300)の境界
  - **境界値での動作保証**: 最大長データでもデコード・表示が正常に機能

- **入力値**:
  ```typescript
  // デコード後: {
  //   word: "あ".repeat(50),  // 50文字（最大値）
  //   meaning: "い".repeat(300) // 300文字（最大値）
  // }
  ```
  - **境界値選択の根拠**: REQ-013（word最大50文字）、REQ-014（meaning最大300文字）
  - **実際の使用場面**: ユーザーが最大文字数まで入力したケース

- **期待される結果**:
  - デコード成功
  - すべての文字が正しく保持される
  - パフォーマンス劣化なし（NFR-001: 3秒以内）
  - **境界での正確性**: 50文字と300文字が正確にデコードされる
  - **一貫した動作**: 短い文字列と同じ品質でデコードされる

- **テストの目的**: REQ-013, REQ-014の境界値動作確認
  - **堅牢性の確認**: 最大データ量でもシステムが安定動作

- 🔵 信頼性レベル: REQ-013, REQ-014, VALIDATION_RULES定義に基づく

---

#### TC-DECODE-011: 最小長データ（word: 1文字、meaning: 1文字）を正しくデコードする

- **テスト名**: 最小長データ（word: 1文字、meaning: 1文字）を正しくデコードする
  - **境界値の意味**: 最小の有効データ長
  - **境界値での動作保証**: 1文字でもデコード・表示が正常

- **入力値**:
  ```typescript
  // デコード後: { word: "愛", meaning: "心" }
  ```
  - **境界値選択の根拠**: 最小の有効データ（空文字列は無効、1文字は有効）
  - **実際の使用場面**: ユーザーが短い言葉を贈るケース

- **期待される結果**:
  - デコード成功
  - 1文字のデータが正しく表示される
  - **境界での正確性**: 文字が欠損しない
  - **一貫した動作**: 長い文字列と同じ処理パイプライン

- **テストの目的**: 最小データでのデコード機能確認
  - **堅牢性の確認**: エッジケースでもシステムが正常動作

- 🟡 信頼性レベル: 最小境界値の一般的なテストプラクティスに基づく

---

#### TC-DECODE-012: URLパラメータがnullの場合はリダイレクトされる

- **テスト名**: URLパラメータがnullの場合はリダイレクトされる
  - **境界値の意味**: `searchParams.get('data')`がnullを返すケース
  - **境界値での動作保証**: null値の適切な処理

- **入力値**:
  ```typescript
  // URL: /display (dataパラメータなし)
  // searchParams.get('data') → null
  ```
  - **境界値選択の根拠**: URLパラメータ不在は頻発するエッジケース（REQ-212）
  - **実際の使用場面**: ユーザーが直接/displayにアクセス、ブックマークから古いURLを開く

- **期待される結果**:
  - `navigate('/', { replace: true })`が呼ばれる
  - トップページにリダイレクト
  - エラーメッセージが表示されない（トーストなし）
  - DisplayPageの他の処理が実行されない
  - **境界での正確性**: リダイレクトが即座に実行される
  - **一貫した動作**: TASK-0025で実装済みのロジックと整合

- **テストの目的**: REQ-212（リダイレクト処理）の動作確認
  - **堅牢性の確認**: パラメータ不在でもアプリケーションがクラッシュしない

- 🔵 信頼性レベル: REQ-212, TASK-0025既存実装、DisplayPage.test.tsx Line 66-80に基づく

---

### 4. 統合テストケース（ToastContext連携）

#### TC-DECODE-013: エラー後に「新しい言葉を贈る」ボタンで復帰できる

- **テスト名**: エラー後に「新しい言葉を贈る」ボタンで復帰できる
  - **統合テストの目的**: エラー状態からの復帰フローの確認
  - **ユーザー体験の重要性**: エラー発生後にユーザーが次のアクションを取れる

- **入力値**:
  ```typescript
  // 1. 不正なデータでアクセス → エラー表示
  // 2. 「新しい言葉を贈る」ボタンをクリック
  ```
  - **シナリオの意味**: エラー発生→リカバリーの完全なユーザーフロー
  - **実際の使用場面**: ユーザーがエラーURLを踏んだ後、正しい使い方を試みる

- **期待される結果**:
  - ErrorPageが表示される
  - 「新しい言葉を贈る」ボタンが表示される
  - ボタンクリックでトップページ（/）に遷移
  - エラー状態がクリアされる
  - トップページで新しい言葉を作成できる
  - **ユーザー体験**: エラーから簡単に回復でき、作業を続行できる

- **テストの目的**: REQ-206（ナビゲーションボタン）とエラーリカバリーの確認
  - **品質保証の観点**: エラー状態がユーザーをブロックしない

- 🟡 信頼性レベル: REQ-206, ErrorPage実装（TASK-0027）から推測

---

#### TC-DECODE-014: ToastContextが正しく統合されている

- **テスト名**: ToastContextが正しく統合されている
  - **統合テストの目的**: ToastProviderとの連携動作確認
  - **Context統合の重要性**: showToast()が正しく呼び出される

- **入力値**:
  ```typescript
  // 不正なBase64データ
  // URL: /display?data=invalid!!!base64
  ```
  - **シナリオの意味**: ToastContextのuseToast()フックが正しく動作
  - **実際の使用場面**: エラー発生時のトースト通知

- **期待される結果**:
  - `useToast()`が例外をスローしない（Providerが存在）
  - `showToast(message, 'error')`が呼び出される
  - Toastコンポーネントにエラーメッセージが渡される
  - トーストが画面に表示される
  - **Context統合**: ToastProviderのstate更新が正しく機能

- **テストの目的**: アーキテクチャ制約（React Context API使用）の確認
  - **品質保証の観点**: Context統合の正確性

- 🔵 信頼性レベル: ToastContext.tsx実装、アーキテクチャ制約条件に基づく

---

## テストケース実装時の日本語コメント指針

### テストケース開始時のコメント

```typescript
// 【テスト目的】: URLパラメータから正しくBase64デコードしてデータを表示する（REQ-103）
// 【テスト内容】: 有効なBase64エンコードデータをdecodeGiftWordDataでデコードし、DisplayPageに表示
// 【期待される動作】: デコード成功、エラーなく表示、トーストメッセージなし
// 🔵 信頼性レベル: REQ-102, REQ-103に基づく
```

### Given（準備フェーズ）のコメント

```typescript
// 【テストデータ準備】: 日本語を含む有効なGiftWordDataをBase64エンコード
const testData: GiftWordData = { word: '感謝', meaning: 'いつもありがとう' };
const encodedData = btoa(encodeURIComponent(JSON.stringify(testData)));

// 【初期条件設定】: ToastProviderとRouterでラップしてDisplayPageをレンダリング
// 【前提条件確認】: URLパラメータに有効なdataが含まれている
renderWithRouter([`/display?data=${encodedData}`]);
```

### When（実行フェーズ）のコメント

```typescript
// 【実際の処理実行】: DisplayPageコンポーネントがマウントされ、useEffect内でデコード処理が実行される
// 【処理内容】: searchParams.get('data') → decodeGiftWordData() → setData()
// 【実行タイミング】: コンポーネントマウント時（useEffect依存配列: [searchParams]）
```

### Then（検証フェーズ）のコメント

```typescript
// 【結果検証】: デコードが成功し、エラーが発生していないことを確認
// 【期待値確認】: ErrorPageが表示されず、メインコンテンツが表示される
// 【品質保証】: 正常系フローが正しく動作し、ユーザーにデータが表示される

await waitFor(() => {
  // 【検証項目】: エラーページが表示されていない 🔵
  expect(screen.queryByText(/エラー/i)).not.toBeInTheDocument();

  // 【検証項目】: 「新しい言葉を贈る」ボタンが表示される（正常表示の証拠） 🔵
  expect(screen.getByRole('button', { name: /新しい言葉を贈る/i })).toBeInTheDocument();
});
```

### セットアップ・クリーンアップのコメント

```typescript
beforeEach(() => {
  // 【テスト前準備】: ToastContextのstateをクリアにリセット
  // 【環境初期化】: 各テストが独立して実行されることを保証
  // （ToastProviderは各テストで新しくマウントされるため、自動的にクリーン）
});

afterEach(() => {
  // 【テスト後処理】: モックのクリーンアップ（vi.clearAllMocks()）
  // 【状態復元】: 次のテストに影響しないようにメモリをクリア
});
```

---

## テストケース統計

### 総テストケース数

- **正常系**: 3ケース（TC-DECODE-001 ~ TC-DECODE-003）
- **異常系**: 6ケース（TC-DECODE-004 ~ TC-DECODE-009）
- **境界値**: 3ケース（TC-DECODE-010 ~ TC-DECODE-012）
- **統合**: 2ケース（TC-DECODE-013 ~ TC-DECODE-014）
- **合計**: 14ケース

### 要件カバレッジ

| 要件ID | 要件名 | テストケース |
|--------|--------|-------------|
| REQ-102 | URLパラメータ形式 | TC-DECODE-001, TC-DECODE-012 |
| REQ-103 | Base64デコード | TC-DECODE-001 ~ TC-DECODE-011 |
| REQ-212 | リダイレクト処理 | TC-DECODE-012 |
| REQ-213 | エラーメッセージ | TC-DECODE-004 ~ TC-DECODE-009, TC-DECODE-013 |
| REQ-021 | 日本語対応 | TC-DECODE-002 |
| REQ-013 | word最大50文字 | TC-DECODE-010 |
| REQ-014 | meaning最大300文字 | TC-DECODE-010 |
| REQ-206 | ナビゲーションボタン | TC-DECODE-013 |
| NFR-001 | ページ読み込み3秒以内 | TC-DECODE-010 |

### 信頼性レベル分布

- 🔵 **青信号（高信頼）**: 10ケース（71%）
- 🟡 **黄信号（中信頼）**: 4ケース（29%）
- 🔴 **赤信号（低信頼）**: 0ケース（0%）

---

## 品質判定

### ✅ 高品質

- **テストケース分類**: 正常系・異常系・境界値・統合が網羅されている
- **期待値定義**: 各テストケースの期待値が明確（エラーメッセージ、State変化、UI表示）
- **技術選択**: TypeScript + Vitest + React Testing Library（確定）
- **実装可能性**: 既存のurlEncoder.test.tsとDisplayPage.test.tsのパターンを活用可能

### カバレッジ分析

- **正常系カバレッジ**: 100%（正常デコード、日本語、特殊文字）
- **異常系カバレッジ**: 100%（空文字、不正Base64、JSONエラー、データ欠損）
- **境界値カバレッジ**: 100%（最大長、最小長、null）
- **統合カバレッジ**: 100%（ToastContext、ErrorPageリカバリー）

---

## 次のステップ

✅ **テストケース洗い出しフェーズ完了**

**次のお勧めステップ**: `/tsumiki:tdd-red` でRedフェーズ（失敗するテスト作成）を開始します。

---

## 更新履歴

- 2025-11-22: 初回作成（/tsumiki:tdd-testcasesにより生成）
  - 14個のテストケースを定義
  - 正常系3、異常系6、境界値3、統合2
  - 要件カバレッジ100%
